# 1. Service

초급편에선, 사용자의 입장에서 서비스를 다루었지만, 중급편에선, Pod의 입장에서 다룰 것이다.

## 개요

<img src=./image/>

사용자의 접근의 경우 서비스가 만들어진 후에 IP를 확인하고 그 IP로 접근을 하면되는데,

Pod의 경우 이 자원들이 동시에 배포가 될 수 있다.  
이럴 때 Pod A가 Pod B로 접근을 해야하는데, 파드b의 ip를 넣기에는 ip는 동적으로 할당되기 때문에, 미리 알 수가 없다.  
또한, 파드 b가 문제가 생겨 재생성이 되면, ip는 계속 바뀌기 때문에 파드 a가 지속적으로 쓸 수가 없다.

-> 이러한 문제를 해결하고, 파드 a가 파드 b와 서비스의 연결을 하기 위해서는 `Headless`,
`DNS Server`가 필요하다.

파드가 외부 특정 사이트에 접근을 해서 데이터를 가지고 오는 상황에서 접근 주소를 변경해야 하는 상황이 생기면 파드를 변경하고 재배포를 해야할까??

-> Service의 `ExternalName`을 이용해서 외부 연결을 파드의 수정없이 할 수 있다.

<img src=./image/>

k8s cluster안에는 DNS Server가 별도로 존재하는데, 서비스의 도메인 이름과, ip가 저장되어 있다. 파드가 서버1에 대한 도메인 이름을 지정하면 해당 ip를 알려준다.

내부망에서도 DNS Server가 구축되어 있다면, 내부 서버들이 생겼을 때 해당 이름들이 DNS 등록이 되었을 거고,
Pod가 user1을 찾았을 때 K8S의 DNS 없다면, DNS 특성상 상위 DNS를 찾게되고 해당 IP를 알려준다.

외부에 있는 사이트도 도메인 이름이 외부 도메인에 등록되어 있기 때문에 Pod가 Google을 찾으면 부모의 부모를 찾아서 최종적으로 Google의 ip를 찾게 된다.

Pod에서 DNS를 이용해서 원하는 서비스나 외부에 접근을 할 수가 있다.
그래서 파드가 IP를 몰라도 DNS의 서비스 이름으로 IP를 물어봐서 연결을 할 수가 있다.

Pod1이나 Pod2를 선택해서 연결을 하고 싶을 때면 pod에 headless 서비스를 연결을 하면 된다. -> DNS Server에 파드의 이름과 서비스의 이름이 붙여줘서 도메인 이름으로 등록되기 때문에, 파드3의 입장에서 파드1에 접근을 하기 위해서는 IP주소는 필요가 없고, 도메인 이름으로 접근을 할 수가 있다.

`ExternalName` 서비스를 만들어서, 특정 외부 도메인을 넣을 수가 있는데, DNS를 타고 타서 Google ip를 가져올 수 있고, 파드는 이 서비스를 통해서 데이터를 가져오도록 해놓으면, 추후 데이터를 github에서 가져오도록 변경을 했을 때 파드의 수정없이 서비스의 `ExternalName`만 변경하면 된다.

## 1-1. Headless

---

<img src=./image/>

- default NS에 파드 두 개와 서비스가 연결되어 있음. (ClusterIP)
- pod는 pod1에 연결하고 싶음
- K8S DNS가 있는데 이름은 cluster.local이고, 파드든 서비스든 긴 도메인 이름과 ip가 저장이 된다.
- pod는 clusterip를 통해 pod1과 연결을 할 수가 있다.

<img src=./image/>

<DNS 테이블>

Service : 서비스명.NS.svc.DNS명  
Pod : 파드IP,NS,pod,DNS명

-> 이러한 형식을 FQDN이라고 한다. 같은 NS 안에서는 Service는 앞자리만 짧게 써도 되지만, 파드는 모든 것을 입력해야 한다.

---

<img src=./image/>

- 똑같은 상황에서 Pod가 pod4로 직접 연결을 하고 싶음  
  -> 서비스를 Headless 서비스로 만들어야 한다.  
  만드는 방법 : `clusterIP:None`이라고 지정하면 된다.

      pod4를 만들 때 `hostname`이라는 속성의 도메인 이름을 넣어야 하고, `subdomain`에 headless 서비스 명을 넣어야 한다.

<img src=./image/>

ClusterIP와는 다르게 Service의 IP가 없으므로 pod의 ip가 들어갔고,
pod이름의 첫 번째가 파드 IP가 아닌, 생성할 때 지정했던, hostname, subdomain으로 이루어졌기 때문에, pod가 직접 연결을 할 수가 있다.

## 1-2. Endpoint

---

<img src=./image>

- 서비스와 파드를 연결할 때 라벨을 통해서 연결을 한다.
  -> 이것은 사용자 입장에서 둘의 연결을 하기 위한 도구이다.

- K8S는 서비스와 파드가 라벨을 통해 매칭이 됐을 때, Endpoint라는 것을 만들어주고 실제 연결고리를 관리를 한다.

- K8S가 Endpoint를 만드는 방법.
  서비스의 이름과 동일한 이름으로 엔드포인트 이름을 설정하고, 엔드포인트 안에는 파드의 접속 정보를 넣어준다.

-> 이 원리를 알면 LABEL이 없어도 직접 연결을 할 수가 있다.

하지만 IP는 언제든지 변경될 수 있기 때문에, 도메인이름으로 접근을 하는 방법을 알아야 하는데, 그것이 `ExternalName`이다.

## 1-3. ExternalName

---

<img src=./image>

서비스의 externalName이라는 속성을 달아서, 도메인 네임을 넣을 수가 있는데, 이러면 DNS 캐쉬가 내부, 외부 DNS를 찾아서 IP를 알아낸다.

결국, 파드는 서비스를 가리키고만 있으면, 서비스에서 필요시마다 해당 도메인 주소를 변경할 수가 있어서, 접속할 곳이 변경되더라도 파드를 수정하고 재배포할 일이 없어진다.

# 2. Volume

## 개요.

---

<img src=./image>

- 볼륨은 데이터를 안정적으로 유지하기 위해서 사용.
- 그렇기 때문에 실제 데이터는 k8s cluster와 분리가 돼서 관리가 된다.
- 이런 방식으로 관리할 수 있는 볼륨의 종류

  - 외부망 :
    - AWS , GCP, Azure
  - 내부망 :
    - 기본적으로 k8s에서 node들의 실제 물리적인 공간의 데이터를 만들 수 있는 `hostpath`, `local` 볼륨이 있다.
    - 온프라미스 스토리지 솔루션을 별도로 설치할 수 있다.
      StorageOS, ceph, GlusterFS 와 같은 종류가 있고, 이 솔루션들이 알아서 노드의 자원을 이용해 볼륨을 관리한다.
    - NFS를 사용해서 다른 서버를 볼륨서버로 사용할 수 있다.
    - ETC...

- K8S Cluster 밖에 실제 볼륨들이 마련되어 있다면, 관리자는 pv를 만들고, 볼륨을 선택해서 연결을 한다.
- 그리고 사용자는 원하는 용량과 accessmode로 pvc를 만들면 k8s가 알아서 적절한 pv와 연결을 해준다.
- 이 pvc를 pod에서 사용을 한다.

이런 방식으로 볼륨을 사용하면, 볼륨이 필요할 때 마다 pv를 만들어줘야하고, 원하는 pv랑 연결을 하기 위해서 storage나 acessmode를 설정해야 한다. ( 복잡 )

-> K8S에서 `Dynamic Provisioning`해서 사용자가 pvc를 만들면 알아서 pv를 만들어주고 실제로 볼륨을 연결해주는 기능이 있다.

---

모든 pv에는 pod처럼 각각의 상태가 존재하므로, pv가 pvc와 연결되어 있는지, 에러가 났는지, 등등 알 수가 있다.

---

## 2-1. Dynamic Provisioning

---

<img src=./image>

- StorageOS 솔루션을 예시로 설명
- StorageClass를 사용해서 동적으로 pvc를 만들 수가 있다.
- PVC에 `StorageClssName`이라는 속성을 통해 StorageClass를 지정할 수 있다.
- IF ) PVC에 fast 이름을 지정하면 자동으로 StorageOS 볼륨을 가진 pv가 만들어진다.
- StorageClass는 추가로 만들 수 있고, `default`라는 것을 설정할 수 있는데, pvc에서 storageClassName을 생략을 해도 default StorageClass가 적용이 돼서 pv가 만들어 진다.

## 2-2. Status, ReclaimPolicy

---

<img src=./image>

- Status는 최초 pv가 만들어졌을 대 `available` 상태, PVC와 연결이 되면 `Bound` 상태
- PV를 직접 만드는 경우에는 아직 볼륨의 실제 데이터가 만들어진 상태가 아니고, 파드가 PVC를 사용해서 구동이 될 때 실제 볼륨이 만들어진다.
  -> 파드가 구동되다 삭제가 되는 경우에는 PVC와 PV에는 아무런 변화가 없기 때문에, 데이터에 문제는 없다.
  -> PVC를 삭제를 해야 PV가 `Released` 상태로 변화한다.
- 이러한 과정 중에 PV와 실제 데이터 간 연결의 문제가 생기면 `Faild`로 변하기도 한다.

<img src=./image>
PVC가 삭제가 되었을 때 PV에 설정해 놓은 ReclaimPolicy 따라서 PV에 대한 상태가 달라진다.
ReclaimPolicy는 : `Retain, Delete, Recycle` 3가지가 있다.

- Retain : PVC가 삭제가 되면 PV는 Released가 되는데, PV를 만들 때 ReclaimPolicy를 별도로 설정하지 않았을 경우 Default 값이다.
  - 실제 볼륨의 데이터는 유지되지만, PV를 다른 PVC에 연겨을 할 수는 없다.
  - 삭제하고 다시 생성 후 연결해야 한다.
- Delete : PVC를 지우면 PV도 같이 지워진다.
  - StorageClass를 사용해서 자동으로 만들어진 PV의 Default 값이다.
  - 볼륨의 종류에 따라 실제 데이터가 삭제되기도 하고 안되기도 한다.
- Recycle : PV의 상태가 Available이 되면서 PVC에서 다시 연결할 수 있는 상태이다.
  - 지금은 Deprecated 이다.
