# 1. Why Kubernetes?

- <h2> As-Is </h2>

  - 서버의 사용<br>  
    오전에는 A 서비스, 오후엔 B 서비스, 저녁엔 C 서비스 별로 시간 대에 따라 접속량이 몰리는 환경이다.  
    모든 서비스는 다른 시간 대에 서비스 사용량이 적더라도 접속량이 증가하는 시간대가 있기때문에 어쩔 수 없이 서버를 3대씩, 총 9대를 돌려야함.

    <br>

  - 복구 작업<br>  
    서버 장애 상황에 대비해서 한 대에 여분 서버가 필요하고, 각 서버스 별로 백업 서버를 둬야 즉각적인 대응이 가능하다.

    <br>

  - 업데이트<br>  
    서비스의 중단이 허용되는 경우, 모든 서버를 내렸다가 업데이트 작업 후 다시 올릴 것이고,  
    무중단 서비스를 해야하는 경우 한 서버씩 내린 후 업데이트 작업 후에 다시 올리는 방식이다.

    <br>

- <h2> To-Be </h2>

  - 서버의 사용<br>  
    Kubernetes의 가상화 기술을 사용한다면, 하루 총 사용량을 계산해보면 4 대분의 자원이 필요하고, AutoScaling 기술이 있기 때문에 어느 시간대든 트레픽양에 따라 알아서 서비스 자원을 변경시켜준다.

    <br>

    - 복구 작업 <br>  
      장애가 난 서버위에 있는 서비스들이 다른 서버로 자동으로 옮겨주는 Auto Healing 기능이 있기때문에, 한 서버에 장애가 나더라도 여분의 서버 한대만 있으면 알아서 서비스를 유지시켜준다.

    <br>

  - 업데이트 <br>  
    쿠버네티스도 Deployment 오브젝트를 통해서 업데이트 방식에 대해서 자동적으로 처리되도록 지원하고 있다.
    <br>

<br>
<br>
<br>

# 2. VM vs Container

공통 점 : Host Server 위에 Host OS가 깔려있고, 그 위에 설치되는 것은 동일하다.

차이점 :
VM : VM을 가상화 시켜주기 위한 VirtualBox나 VMware와 같은 하이퍼바이저 툴이 있고, 이것들을 사용해서 GuestOS를 올려서 여러 VM을 사용할 수 있다.

- 장점: HostOS처럼 독립적으로 사용할 수 있어, 여러 서비스와 프로그램을 설치해서 사용할 수 있다.

Container : HostOS 위에 컨테이너 가상화를 시켜주는 여러가지 소프트웨어가 있다.(EX -docker)

리눅스마다 버전이 있다.
버전을 따라서 설치되는 라이브러리가 다르다.
리눅스 6 버전에서 애플리케이션을 개발을 하고 7버전에서 동작을 시키면 오류가 날 것이다.
도커를 설치하고 컨테이너 이미지를 만들 수 있고, 이미지에는 한 서비스와 그 서비스에 필요한 라이브러리가 같이 있다. 그렇기 때문에 리눅스 7 버전에 다른 라이브러리가 있더라도 도커만 설치되어 있다면 컨테이너 이미지를 가져와 사용한다면 리눅스 6버전도 안전하게 사용할 수 있다. 여러 컨테이너 간에 호스트 자원을 분리해서 사용하게 해준다.
이것은 리눅스 고유 기술인 namespace와 cgroups 사용해서 격리를 하는 것이다.
namespace는 커널에 관련된 영역을 분리해주고, cgroups은 자원에 대한 영역을 분리해주는 역할을 한다.
정리를 하자면 도커와 같이 컨테이너 가상화 솔루션들을 os에서 제공해주는 자원 격리 기술을 이용해서 컨테이너라는 단위로 서비스를 분리할 수 있게 해주고, 컨테이너 가상화가 깔려있는 os에서는 개발환경에 대한 걱정없이 배포가 가능해진다.

결론.
시스템 구조적으로 Container는 한 OS를 공유하는 개념이고,
VM은 각각의 OS를 따로 띄어야 하는 구조이기 때문에 Container가 더 빠르다.

하지만 단점이 있는데, VM은 윈도우 OS를 쓰고 있더라도, Guest OS에서 Linux OS를 사용할 수 있지만, Container는 Linux OS에서 Window OS를 사용할 수 없다.
보안적으로 VM은 Guest OS가 뚫려도 다른 Guest OS나 Host OS와는 완벽하게 분리되어 있기 때문에 피해가 가지 않지만, Container는 한 Cotainer가 뚫려 OS 영역에 접근을 하게 되면 다른 Container도 위험해질 수 있다.

<br>

# 3. Getting started - kubernetes

### 실습 시나리오.

<img src=./image/Getting_started.png>

1. Linux 서버에서 Nodejs 웹을 하나 만들어서 띄울거임.
2. Docker가 깔려있는 서버에서 앞에서 만든 Nodejs 웹을 가지고 와서 실행을 할건데 Nodejs가 깔려있지 않기 때문에 실행이 안됨.
   DockerHub에서 Nodejs를 실행할 수 있는 컨테이너 이미지를 가져와서 앞에서 만든 웹을 붙여서 또 다른 이미지로 만들고 DockerHub에 올릴거임.
3. 쿠버네티스가 깔려있는 서버에서 방금 올린 이미지를 가지고 와서 POD를 만들 거임.
   또한 서비스를 추가해서 외부에서 접근이 가능하게 할거임.

<br>

# 4. Getting started - kubernetes - 실습

이 부분은 좀 더 배우고 진행하겠음.

---

<br>

# 5. Kubernetes Overview

<img src=./image/Overview.png>

쿠버네티스는 마스터 node와 worker 노드들이 연결되어 있는 것을 하나의 kubernetes Cluster라고 부른다.

마스터는 쿠버네티스의 전반적인 기능들을 컨트롤하는 역할이고 노드들은 자원을 제공해주는 역할을 한다.

Cluster 안에서는 Namespace라는 것이 쿠버네티스의 오브젝트들을 독립된 공간으로 분리되게 만들어준다.

Namespace에는 쿠버네티스의 최소 배포 단위인 pod들이 있고 이 pod들이 외부로부터 연결이 가능하도록 ip를 할당해주는 서비스가 있지만

서로 다른 namespace에 있는 pod와는 연결은 불가능하다.

파드 안에는 여러 컨테이너가 있고, 컨테이너 하나당 하나의 앱이 동작하게 된다.

파드가 문제가 생겨 재생성이 되면 그 안에 있는 데이터가 날아가기 때문에 Volume을 만들어서 데이터를 저장할 수 있다.

Namespace에 `ResourveQuota/LimitRange`를 달아서 자원의 양을 한정시킬 수도 있다. (ex. pod양, cpu, memory 사용량 등)

pod 생성시 컨터이너 안에 환경 변수 값을 넣거나 파일을 마운트 해줄 수가 있는데, `ConfingMap/Secret`을 통해 이루어진다.

Controller는 Pod들을 관리해주는데 종류가 여러가지가 있다.

<img src=./image/controller.png>

Replication Controller와 ReplicaSet은 파드가 죽으면 감지해서 다시 살려주거나, 갯수를 늘리거나 줄일 수가 있다.

Deployment는 배포 후에 파드들을 새 버전으로 업글레이드를 해주고, 업그레이드 와중에 문제가 생기더라도 RollBack을 시켜준다.

DaemonSet은 한 Node에 파드가 하나씩만 유지가 되도록 하게 해준다. 이렇게 해야하는 모듈들이 있는데, 해당 강의에서 배울 것임.

Job은 어떤 특정 작업만 하고 종료를 시켜야 할 때 파드가 그렇게 동작하게 해준다. 이런 Job을 주기적으로 실행해야할 때는 CronJob을 사용한다.

-> 전반적인 흐름이다.
